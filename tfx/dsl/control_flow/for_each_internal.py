# Copyright 2022 Google LLC. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Internal shared classes for ForEach."""

import collections
from typing import Any, Callable, Dict, Generic, Sequence, TypeVar

import attr
from tfx.dsl.context_managers import dsl_context
from tfx.orchestration import pipeline
from tfx.types import channel as channel_types


# Avoid cyclic dependency
_BaseNode = Any


@attr.s(auto_attribs=True, kw_only=True, hash=False, eq=False)
class ForEachContext(dsl_context.DslContext):
  """DslContext for ForEach."""
  # The return value of the `ForEach.__enter__()`, or the variable in the `as`
  # clause of the `ForEach`. Typically it is a BaseChannel or a sequence of
  # BaseChannels, but can be Any.
  # This is automatically set from `ForEach.enter()`. Do not set this directly.
  loop_variable: Any = None

  def __hash__(self) -> int:
    return hash(id(self))

  def __eq__(self, other: Any) -> bool:
    return other is self

  def _validate_all_nodes(self, containing_nodes: Sequence[_BaseNode]):
    """Validates that all nodes are in a pipeline."""
    found_nodes = collections.Counter()

    # This block filters out any node contained in a pipeline that is also in
    # containing_nodes.
    for node in containing_nodes:
      found_nodes[node.id] += 1
      if isinstance(node, pipeline.Pipeline):
        for node in node.components:
          found_nodes[node.id] -= 1

    # There should be one remaining node
    remaining_nodes = [node for node in found_nodes if found_nodes[node] != 0]

    # TODO: b/247709394 - Enforce that one component must be provided.
    if len(remaining_nodes) > 1:
      raise ValueError(
          'Multiple nodes are only allowed in a ForEach if they are all in a'
          f' subpipeline. Found {remaining_nodes} which are not.'
      )

  # TODO(b/237363715): Raise if containing nodes does not use loop variable
  # neither directly nor indirectly.
  def validate(self, containing_nodes: Sequence[_BaseNode]):
    for parent in self.ancestors:
      if isinstance(parent, ForEachContext):
        raise NotImplementedError('Nested ForEach block is not supported yet.')

    self._validate_all_nodes(containing_nodes)


_ChannelDict = Dict[str, channel_types.BaseChannel]
LoopVar = TypeVar('LoopVar')
_ForEach = TypeVar('_ForEach', bound=ForEachContext)


class Loopable(Generic[LoopVar]):
  """A loopable object can be used with ForEach.

  with ForEach(loopable) as handle:
    ...

  A `handle` object would be generated by calling the `loop_var_factory` with
  the corresponding `ForEachContext`. Return value of the `loop_var_factory`
  would be passed as an `handle`.
  """

  def __init__(
      self, loop_var_factory: Callable[[_ForEach], LoopVar]):
    if not callable(loop_var_factory):
      raise ValueError(f'{loop_var_factory} is not callable.')
    self._loop_var_factory = loop_var_factory

  def get_loop_var(self, context: ForEachContext) -> LoopVar:
    return self._loop_var_factory(context)

  def __getitem__(self, *unused_args):
    raise RuntimeError(
        'Cannot use loopable value directly. Please use ForEach to wrap it.')
